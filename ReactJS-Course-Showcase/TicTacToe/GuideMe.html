<!--===========================================-->
<!--========== Guide Me Step-By-Step ==========-->
<!--===========================================-->

<!--? 01. First Step -->
-> Start in [ in App.jsx ]
<main>
  <div id="game-container">
    <li>Players</li>

    <div>GameBoard</div>
  </div>

  <ol>
    Log
  </ol>
</main>

-> Then, start with (Players)

<!--======================================================-->
<!--? 02. Player -->
-> The order is matter [ in App.jsx ]
<ol id="players">
  <li>
    <span className="player">
      <span className="player-name">Player 1</span>
      <span className="player-symbol">X</span>
    </span>

    <button>Edit</button>
  </li>

  <li>
    <span className="player">
      <span className="player-name">Player 2</span>
      <span className="player-symbol">O</span>
    </span>

    <button>Edit</button>
  </li>
</ol>

<!--======================================================-->
<!--? 03. building reuseable Player-component  -->
=>> [ in App.jsx ]
<ol id="players">
  <Player name="Player 1" symbol="X" />
  <Player name="Player 2" symbol="O" />
</ol>

=>> [ in Player.jsx ] function Player({ name, symbol }) { return (
<li>
  <span className="player">
    <span className="player-name">{name}</span>
    <span className="player-symbol">{symbol}</span>
  </span>

  <button>Edit</button>
</li>
); }

<!--======================================================-->
<!--? 04. make the "Button" works -> update the "playerName" -->
<!--? therefore manage some "state" to update the UI -->

<!-- 
function Player({ name, symbol }) {
  const [isEditing, setIsEditing] = useState(false);   ðŸ‘ˆ

  function handleEditing() {         ðŸ‘ˆ
    setIsEditing((editing) => !editing);
  }

  let playerName = <span className="player-name">{name}</span>;  ðŸ‘ˆ
  if (isEditing) {         ðŸ‘ˆ
    playerName = <input type="text" required value={name} />;
  }

  return (
    <li>
      <span className="player">
        {playerName}      ðŸ‘ˆ
        <span className="player-symbol">{symbol}</span>
      </span>

      <button onClick={handleEditing}>{isEditing ? 'Save' : 'Edit'}</button> ðŸ‘ˆ
    </li>
  );
} -->

<!--======================================================-->
<!--? 05. get the changes that the user tries to apply to this "value" 
-> playerName = <input type="text" required value="{name}" />;
-->

<!--? so we can update the playerName here: 
-> let playerName = <span className="player-name">{name}</span>;
-->

<!-- 
function Player({ initialName, symbol }) {
  const [isEditing, setIsEditing] = useState(false);
* const [playerName, setPlayerName] = useState(initialName);  ðŸ‘ˆ

  function handleEditing() {
    setIsEditing((editing) => !editing);
  }

* function handleChange(e) {         ðŸ‘ˆ
    setPlayerName(e.target.value);
  }

* let editablePlayerName = <span className="player-name">{playerName}</span>; ðŸ‘ˆ
  if (isEditing) {
    editablePlayerName = (
    * <input type="text" required value={playerName} onChange={handleChange} ðŸ‘ˆ
    );
  }

  return (
    <li>
      <span className="player">
      * {editablePlayerName}   ðŸ‘ˆ
        <span className="player-symbol">{symbol}</span>
      </span>

      <button onClick={handleEditing}>{isEditing ? 'Save' : 'Edit'}</button>
    </li>
  );
}

 -->

<!--======================================================-->
<!--? 06. GameBoard.jsx  -->

<!-- 
const initialGameBoard = [   =>> create a "Grid" of 3row & 3column
  [null, null, null],
  [null, null, null],
  [null, null, null],
];

function GameBoard() {
  return (
    <ol id="game-board">     =>> dynamically rendering this "Grid"
      {initialGameBoard.map((row, rowIndex) => (
        <li key={rowIndex}>
          <ol>
            {row.map((playerSymbol, colIndex) => (
              <li key={colIndex}>
                <button>{playerSymbol}</button>
              </li>
            ))}
          </ol>
        </li>
      ))}
    </ol>
  );
}
-->

<!--======================================================-->
<!--? 07. make this buttons work: <button>{playerSymbol}</button> -->
<!--? GameBoard.jsx  -->

<!-- So, that it can change, then we update the UI and we place the "symbol" of the player who clicked a button

then, replace the gameBoard with the new-gameBoard where one field will change from "null" to either an "X or O" depending on which player clicked the button -->

<!-- function GameBoard() {
* const [gameBoard, setGameBoard] = useState(initialGameBoard);  ðŸ‘ˆ

* function handleSelectSquare(rowIndex, colIndex) {    ðŸ‘ˆ
    setGameBoard((prevGameBoard) => {
     ! /=> get new-array full of new-nested-arrays since we're dealing with reference-value and to avoid bugs <==/
      const updatedBoard = [
        ...prevGameBoard.map((innerArray) => [...innerArray]),
      ];

    ! /=> Find the first empty square and place a "X" in it.
      updatedBoard[rowIndex][colIndex] = 'X';
      return updatedBoard;
    });
  }

  return (
    <ol id="game-board">
    * {gameBoard.map((row, rowIndex) => (    ðŸ‘ˆ
        <li key={rowIndex}>
         <ol>
          {row.map((playerSymbol, colIndex) => (
            <li key={colIndex}>
          *  <button onClick={() => handleSelectSquare(rowIndex, colIndex)}> ðŸ‘ˆ
                  {playerSymbol}
              </button>
            </li>
          ))}
          </ol>
        </li>
      ))}
    </ol>
  );
}
 -->

<!--* this map() here; since we're dealing some nested arrays those should be copied as well before we update anything
  const updatedBoard = [
        ...prevGameBoard.map((innerArray) => [...innerArray]),
      ]; -->

<!--* updatedBoard[rowIndex][colIndex] = 'X';  
on this updatedBoard select one of these 3arrays - and then one of the elements inside of that inner-array -->

<!--======================================================-->
<!--? 08. switch between players | place the symbol of active-player  -->
<!-- 
  we need to know about the currently active-player in both "PLayer-component" and in the "GameBoard-component" !
  in "PLayer-component"-> add a active css class to active-player
  in "GameBoard-component"-> we need the symbol of active-player

  => These are two separated-component, how we can sure which player is currently active? Here we use:
  * Lifting State Up
  -> instead of managing the info which player is active in the "GameBoard" or the "Player" component, we need to manage state in the "closest-ancestor-component" -> it means, here, in App-component
 -->

<!--? [App.jsx]-->
<!-- 
 import { useState } from 'react';   ðŸ‘ˆ

function App() {
  const [activePlayer, setActivePlayer] = useState('X');   ðŸ‘ˆ

  function handleSelectSquare() {         ðŸ‘ˆ
    setActivePlayer((currActivePlayer) =>
      currActivePlayer === 'X' ? 'O' : 'X'
    );
  }

  return (
    <main>
      <div id="....">  
        <ol id="players" className='highlight-player'>  ðŸ‘ˆ
          <Player initialName="Player 1" symbol="X" />
          <Player initialName="Player 2" symbol="O" />
        </ol>

        <GameBoard onSelectSquare={handleSelectSquare} />   ðŸ‘ˆ
      </div>
    </main>
  );
}

* function handleSelectSquare() =>
-> switching the active-player

* className='highlight-player' => 
-> add a css class to the active-player
-> then pass the information of these two player-active to Player-component

* onSelectSquare={handleSelectSquare} => 
-> pass down as props to GameBoard component -->

<!--?[GameBoard.jsx]-->
<!-- 
 * function GameBoard({ onSelectSquare }) {   ðŸ‘ˆ
  ....

  function handleSelectSquare(rowIndex, colIndex) {
    setGameBoard((prevGameBoard) => {
    .....
    });

 *   onSelectSquare();      ðŸ‘ˆ
  } 

  return (
    <ol id="game-board">
      ....
    </ol>
  );
} -->

<!--?[Player.jsx]-->
<!-- 
function Player({ initialName, symbol,  * isActive }) {  ðŸ‘ˆ
  ......

  function handleEditing() {
    .....;
  }

  function handleChange(e) {
   ......
  }

  let editablePlayerName = <span className="player-name">{playerName}</span>;
  if (isEditing) {
    ......
  }

  return (
    <li className={isActive ? 'active' : undefined}>   ðŸ‘ˆ
      <span className="player">
        {editablePlayerName}

        <span className="player-symbol">{symbol}</span>
      </span>

      <button onClick={handleEditing}>{isEditing ? 'Save' : 'Edit'}</button>
    </li>
  );
}-->

<!--?[App.jsx]-->
<!-- 
  return (
    <main>
      <div id="game-container" className="highlight-player">
        <ol id="players">
          <Player
            initialName="Player 1"
            symbol="X"
    *        isActive={activePlayer === 'X'}   ðŸ‘ˆ
          />
          <Player
            initialName="Player 2"
            symbol="O"
    *        isActive={activePlayer === 'O'}    ðŸ‘ˆ
          />
        </ol>

        <GameBoard onSelectSquare={handleSelectSquare} />
      </div>
    </main>

* isActive={activePlayer === 'X'} =>
-> this player is active if is equal to "X"
  );-->

<!-- 
    IN THE END, we need to pass "activePLayer" to the "GameBoard" because activePlayer is the symbol of the player that's currently active and we need that "symbol" to place it on the "square that was clicked"
   -->
<!--?[GameBoard.jsx]-->
<!-- 
 * function GameBoard({ onSelectSquare, * activePlayerSymbol }) {  ðŸ‘ˆ
  ......

  function handleSelectSquare(rowIndex, colIndex) {
    setGameBoard((prevGameBoard) => {
     ...... 

*      updatedBoard[rowIndex][colIndex] = activePlayerSymbol; ðŸ‘ˆ
      
      .....
    });

    onSelectSquare();
  }

  return (
    <ol id="game-board">
      ......
    </ol>
  );
}-->

<!--?[App.jsx]-->
<!-- 
  <main>
      <div id="game-container">
        <ol id="players" className="highlight-player">
          <Player
            initialName="Player 1"
            symbol="X"
            isActive={activePlayer === 'X'}
          />
          <Player
            initialName="Player 2"
            symbol="O"
            isActive={activePlayer === 'O'}    
          />
        </ol>

        <GameBoard
          onSelectSquare={handleSelectSquare}
  *        activePlayerSymbol={activePlayer}     ðŸ‘ˆ
        />
      </div>
    </main>

? activePlayerSymbol={activePlayer} =>
-> setting the prop to the component
  -->

<!--======================================================-->
<!--? 09. work on Log-component  -->
<!-- At this point, we're on the edge of writing suboptimal React code, especially if we want to add more features -->

<!-- 
  output information about the different turns-> which turn  were taken by the different players whilst playing that game

  -> that means, we need to manage some dynamic array of turns, an array that grows with every button click

  -> that of course means that we can't manage that state in "Log.jsx" because that info which button was clicked is generated in the "GameBoar.jsx"

  -> we need "lift state up" to the "App-component"
  *-> AVOID adding a new-state to store the same information just with a little bit of extra data:
  -> THEREFORE; we lift the state that manages the current information about the progress of our game up from the "GameBoar-component" to the "App-component"
  -->

  <!--? [in GameBoard.jsx] comment out or delete this state:
 const [gameBoard, setGameBoard] = useState(initialGameBoard);

  function handleSelectSquare(rowIndex, colIndex) {
    setGameBoard((prevGameBoard) => {
      / get new-array full of new-nested-arrays since we're dealing with reference-value and to avoid bugs
      const updatedBoard = [
        ...prevGameBoard.map((innerArray) => [...innerArray]),
      ];

      / Find the first empty square and place a "X" in it.
      updatedBoard[rowIndex][colIndex] = activePlayerSymbol;
      return updatedBoard;
    });

    onSelectSquare();
  } -->
  
  <!--? [in App.jsx] add this state to manage info about different button clicks as a list and then derive both info we need for the "Log" and "GameBoard"
  function App() {
  const [gameTurns, setGameTurns] = useState([]);     ðŸ‘ˆ
  
  .......

  return (
    <main>
      <div id="game-container">
        ......
      </div>

      <Log />
    </main>
  );
}

* useState([]) =>
-> manage an array of turn-data
-->


<!--======================================================-->
<!--? 10. working on the same button can't clicked multiple times  -->
